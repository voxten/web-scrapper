apiVersion: apps/v1
kind: Deployment
metadata:
  name: gui-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gui
  template:
    metadata:
      labels:
        app: gui
    spec:
      containers:
        - name: gui
          image: python:3.9
          command: ["python"]
          args: ["scraping_app.py"]
          ports:
            - containerPort: 5000
          volumeMounts:
            - name: app-volume
              mountPath: /app
      volumes:
        - name: app-volume
          configMap:
            name: gui-config
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: gui-config
data:
  scraping_app.py: |
    from flask import Flask, jsonify, request
    import os
    import pymongo
    import asyncio
    import re
    import requests
    from bs4 import BeautifulSoup
    from pymongo.server_api import ServerApi

    # Flask app initialization
    app = Flask(__name__)

    # Fetching MongoDB connection details from environment variables
    mongo_host = os.getenv('MONGO_HOST', 'localhost')
    mongo_port = os.getenv('MONGO_PORT', '27017')
    mongo_url = f"mongodb://{mongo_host}:{mongo_port}/"

    client = pymongo.MongoClient(mongo_url, server_api=ServerApi('1'))

    mydb = client["Projekt"]
    db_email = mydb["Emaile"]
    db_email1 = mydb["jol"]

    # Send a ping to confirm a successful connection
    try:
        client.admin.command('ping')
        print("Pinged your deployment. You successfully connected to MongoDB!")
    except Exception as e:
        print(e)

    # Asynchronous functions for scraping and parsing
    async def fetch_content(url):
        response = requests.get(url)
        if response.status_code == 200:
            return response.text
        else:
            return None

    async def parse_phone_numbers(html, patterns):
        if html:
            soup = BeautifulSoup(html, 'html.parser')
            phone_numbers = []
            for pattern in patterns:
                phone_numbers.extend(re.findall(pattern, soup.get_text()))
            return list(set(phone_numbers))
        else:
            return None

    async def parse_emails(html):
        if html:
            emails = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', html)
            return list(set(emails))
        else:
            return None

    async def parse_street_names(html):
        if html:
            soup = BeautifulSoup(html, 'html.parser')
            street_names = [tag.get_text() for tag in soup.find_all(string=re.compile(r'^ul\.', re.IGNORECASE))]
            return list(set(street_names))
        else:
            return None

    async def parse_cities(html):
        city_file = 'city_names.txt'
        if html:
            soup = BeautifulSoup(html, 'html.parser')
            try:
                with open(city_file, 'r') as f:
                    city_names = [line.strip() for line in f]
            except FileNotFoundError:
                print("City file not found.")
                return None

            cities = []
            for city_name in city_names:
                city_matches = soup.find_all(string=re.compile(r'\b{}\b'.format(re.escape(city_name)), re.IGNORECASE))
                if city_matches:
                    cities.extend(city_matches)
            return list(set(cities))  # Remove duplicates
        else:
            return None

    # Flask routes
    @app.route('/')
    def home():
        return "Welcome to the Flask and MongoDB app!"

    @app.route('/scrape', methods=['GET'])
    async def scrape():
        url = 'https://informatyk24.elblag.pl/'
        html = await fetch_content(url)

        phone_number_patterns = [
            r'\b(?:\d{3} \d{3} \d{3}|\d{2} \d{3} \d{2} \d{2})\b',  # xxx xxx xxx or xx xxx xx xx
            r'\b\d{3}-\d{3}-\d{3}\b',  # xxx-xxx-xxx
            r'\b\d{3}.\d{3}.\d{3}\b',  # xxx.xxx.xxx
            r'\b\d{4} \d{3} \d{3}\b',  # xxxx xxx xxx
            r'\b\+\d{2} \d{3} \d{3} \d{3}\b',  # +xx xxx xxx xxx
            r'\b\+\d{2} \d{3}-\d{3}-\d{3}\b'  # +xx xxx-xxx-xxx
            # Add your own patterns here
        ]

        tasks = [
            parse_phone_numbers(html, phone_number_patterns),
            parse_emails(html),
            parse_street_names(html),
            parse_cities(html)  # Parsing cities using city names file
        ]

        phone_numbers, emails, street_names, cities = await asyncio.gather(*tasks)

        results = {
            "phone_numbers": phone_numbers,
            "emails": emails,
            "street_names": street_names,
            "cities": cities
        }

        return jsonify(results)

    if __name__ == "__main__":
        app.run(host='0.0.0.0', port=5000)
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: html-templates
data:
  index.html: |
    <!doctype html>
    <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <title>Scraped Data</title>
      </head>
      <body>
        <div class="container">
          <h1 class="mt-5">Scraped Data</h1>
          <table class="table">
            <thead>
              <tr>
                <th scope="col">Site</th>
                <th scope="col">Data</th>
              </tr>
            </thead>
            <tbody>
              {% for item in data %}
              <tr>
                <td>{{ item.site }}</td>
                <td>{{ item.email }}</td>
                <td>{{ item.email }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </body>
    </html>
---
apiVersion: v1
kind: Service
metadata:
  name: gui-service
spec:
  selector:
    app: gui
  ports:
    - protocol: TCP
      port: 80
      targetPort: 5000
